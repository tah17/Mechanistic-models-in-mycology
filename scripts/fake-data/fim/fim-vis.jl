#
#  Reads the fisher information matrices (FIMs) generated by any of the files in fim/ (in this directory).
#  The FIMs determinant or trace or largest eigenvalues can then be calculated and plotted.
#
using DelimitedFiles
using Optim
using PyCall
using LinearAlgebra
using DataFrames
using CSV
using PyPlot; ENV["MPLBACKEND"]="tkagg"; pygui(true);
include("../../../src/functions.jl")
include("../../../src/ODEs.jl")
path = joinpath(@__DIR__, "../../../data")
@pyimport numpy as np
@pyimport pandas as pd
@pyimport seaborn as sns

n_sims = 100
alphas = collect(0.01:0.05:0.99)

#
# function that reads the output of FIMs obtained by running the files in fim/ for a specified data set, parameter set and choisen noise and
# returns the rank, determinant, trace, eigenvalues and maximum egienvalue of the FIM.
#
function process(dat_set::Int64, dat_length::Float64, p_set::Int64, chosen_noise::Int64, n_sims::Int64)
    tmp = readdlm("$path/parameters.csv", ';')[p_set, :]
    if dat_set == 2
        p_true = convert(Array{Float64,1},  vcat(tmp[1], tmp[3:end]))
    else
        p_true = convert(Array{Float64,1}, tmp)
    end
    no_of_params = length(p_true)
    fims = Array{Union{Float64, Missing},3}(undef, no_of_params, no_of_params, n_sims)
    for i in 1:n_sims
        tmp1 = reshape(readdlm("$path/fims/fims-$dat_set/DE/parameter-set-$p_set/noise-$chosen_noise/fims-$i.csv", ';', Any), (no_of_params, no_of_params))
        tmp1[tmp1 .== "NA"] .= missing
        fims[:, :, i] = convert(Array{Union{Missing, Float64},2}, tmp1)#/dat_length
    end
    working_result = Array{Union{Float64, Missing},2}(undef, no_of_params + 1, n_sims)
    for i in 1:n_sims
        working_result[:, i] = readdlm("$path/fitted-data/fake-data/fitted-data-$dat_set/DE/parameter-set-$p_set/noise-$chosen_noise/working-result-$i.csv", ';', Float64)
    end
    θ_hats, costs = convert(Array{Float64,2}, working_result[1:end-1, :]), working_result[end, :]
    ranks = Array{Union{Float64, Missing},1}(undef, n_sims)
    dets = Array{Union{Float64, Missing},1}(undef, n_sims)
    traces = Array{Union{Float64, Missing},1}(undef, n_sims)
    e_vals = Array{Union{Float64, Missing},2}(undef, no_of_params, n_sims)
    max_e_vals = Array{Union{Float64, Missing},1}(undef, n_sims)
    for i in 1:n_sims
        try
            ranks[i] = rank(fims[:, :, i])
            dets[i] = det(fims[:, :, i])
            traces[i] = tr(pinv(fims[:, :, i]))
            e_vals[:, i] = eigvals(fims[:, :, i])
            max_e_vals[i] = minimum(eigvals(fims[:, :, i]))
        catch err
            ranks[i] = missing
            dets[i] = missing
            traces[i] = missing
            e_vals[:, i] .= missing
            max_e_vals[i] = missing
        end
    end
    return (fims, θ_hats, costs), (ranks, dets, traces, max_e_vals), p_true, e_vals
end

#
# read in the fake data
#
dat_lengths = Array{Float64,1}(undef, 5)
for i in collect(1:5)
    dat_lengths[i] = size(CSV.read("/$path/../fake-data/fake-data-$i/parameter-set-1/noise-1/fake-data-set-1.csv", DataFrame))[1]
end

experiments_rank = Array{Array{Any, 2}, 1}(undef, 5)
for j in 1:5
    rank_per_noise = hcat([process(j, dat_lengths[j], 2, i, n_sims)[2][1] for i in 1:5]...)
    experiments_rank[j] = rank_per_noise
end
exps = ["E1", "E2", "E3", "E4", "E5"]
y_pos_local = np.arange(length(exps))
exps_adj = ["Previous \n Data", "Conv. Design", "Alternative 1", "Alternative 2", "Alternative 3"]
#
# plot traces
#
rank_mean = Array{Float64,2}(undef, (5, 5))
rank_sd = Array{Float64,2}(undef, (5, 5))
ess = Array{Float64,2}(undef, (5, 5))
for (idx, elt) in enumerate(experiments_rank)
    ess[:, idx] = vcat(sum((!ismissing).(elt), dims = 1)...)
    rank_mean[:, idx] = [mean(skipmissing(elt[:,i])) for i in 1:5]
    rank_sd[:, idx] = [std(skipmissing(elt[:,i])) for i in 1:5]./sqrt.(ess[:, idx])
end
colours = ["Blues_d", "BuGn_d", "Oranges_d", "Reds_d", "Purples_d"]
plt.figure(figsize = (18, 6))
for i in 1:5
    plt.subplot("15$i")
    if i==1
        plt.ylabel("FIM Rank", fontsize=20)
    end
    chart = sns.barplot(x = y_pos_local, y = rank_mean[:, i], ci = "none", palette = colours[i])
    plt.xticks(y_pos_local, exps_adj)
    chart.set_xticklabels(chart.get_xticklabels(), rotation=45, horizontalalignment = "right")
    plt.errorbar(x = y_pos_local, y = rank_mean[:, i], yerr = rank_sd[:, i], fmt = "none", c =  "black")
    plt.ylim(5, 14)
    plt.tick_params(labelsize = 15)
end
tight_layout()
